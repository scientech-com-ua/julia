# [Введение](@id man-introduction)

Научные вычисления традиционно требовали высокой производительности, но эксперты в этой области
в основном отдавали предпочтение более медленным динамическим языкам для повседневной работы.
Мы считаем, что существует много веских причин использовать динамические языки для этих приложений,
и мы не ожидаем, что их использование уменьшится.
К счастью, дизайн современных языков и методы компиляции позволяют в основном устранить
компромисс производительности и обеспечить единую среду, достаточно эффективную для прототипирования и
достаточно эффективны для развертывания приложений с высокой степенью производительности.
Язык программирования Julia удовлетворяет этой роли: это гибкий динамический язык,
подходящий для научных а также прикладных вычислений, а его производительность сопоставима с традиционными
статически типизированными языками.

Поскольку компилятор Julia отличается от интерпретаторов, используемых для таких языков, как Python или R,
вы сперва можете обнаружить, что производительность Julia неинтуитивная.
Если вы обнаружите, что что-либо тормозит, то мы настоятельно рекомендуем прочитать раздел
[Советы по повышению производительности](@ref man-performance-tips), прежде чем пытаться что-либо еще.
Как только вы поймете как работает Julia, то легко напишете код, который будет почти такой же быстрый как на C.

В Julia присутствует опциональная типизация, множественная диспетчеризация и хорошая производительность,
достигаемая с помощью вывода типа и
[компиляции в машинный код непосредственно во время работы программы (JIT)](https://ru.wikipedia.org/wiki/JIT),
реализованной с использованием [LLVM](https://ru.wikipedia.org/wiki/Low_Level_Virtual_Machine).
Это мультипарадигма, сочетающая функции императивного, функционального и объектно-ориентированного программирования.
Julia обеспечивает простоту и выразительность для высокоуровневых численных вычислений так же как и такие языки,
как R, MATLAB и Python, но также поддерживает общее программирование.
Чтобы достичь этого, Julia основывается на родословной языков математического программирования,
но также сильно заимствует у популярных динамических языков, включая [Lisp](https://ru.wikipedia.org/wiki/Lisp),
[Perl](https://ru.wikipedia.org/wiki/Perl), [Python](https://ru.wikipedia.org/wiki/Python),
[Lua](https://ru.wikipedia.org/wiki/Lua) и [Ruby](https://ru.wikipedia.org/wiki/Ruby).

Наиболее значительными отклонениями Юлии от типичных динамических языков являются:

  * Ядро языка реализует очень маленькая стандартная библиотека написаная на самой Julia,
    включает примитивные операции, например как целочисленная арифметика
  * Язык богатый набором типов для построения и описания объектов, которые в свою очередь,
    также могут быть использованы для объявления новых типов
  * Возможность определять поведение функции для многих комбинаций типов аргументов посредством
    [множественной диспетчеризации](https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D1%82%D0%BE%D0%B4)
  * Автоматическая генерация эффективного специализированного кода для разных типов аргументов
  * Хорошая производительность, приближающаяся к статически компилируемым языкам, таких как C 

Хотя иногда говорят о динамических языках как о «нетипизированных», они, определенно, не являются такими:
все объекты, как примитивные, так и определяемые пользователем, имеют тип.
Однако отсутствие объявлений типов в большинстве динамических языков означает,
что нельзя указать компилятору о типах значений и часто нельзя явно говорить о типах вообще.
С другой стороны, в статических языках, хотя каждый может (и обычно должен) аннотировать типы для компилятора,
типы существуют только во время компиляции и не могут манипулироваться или выражаться во время выполнения.
В Julia типы сами по себе являются объектами времени выполнения,
а также могут использоваться для передачи информации компилятору.

В то время как простому программисту не нужно явно использовать типы или множественную диспетчеризацию,
они являются основными унифицирующими свойствами Julia: функции определены для разных комбинаций типов аргументов
и применяются путем отправки в наиболее точно соответствующее определение.
Эта модель хорошо подходит для математического программирования, где для первого аргумента неестественно «владеть» операцией,
как в традиционной объектно-ориентированной диспетчеризации.
Операторы - это просто функции со специальными обозначениями - чтобы расширить дополнение к новым пользовательским типам данных,
вы определяете новые методы для функции `+`. Существующий код затем легко применяется к новым типам данных.

Частично из-за вывода типа времени выполнения (дополненного дополнительными аннотациями типа),
а отчасти из-за сильного акцента на производительности с самого начала проекта,
вычислительная эффективность Julia превышает эффективность других динамических языков и даже соперников,
которые статически компилируемы. Для крупномасштабных числовых задач скорость всегда была, по-прежнему остается, и, вероятно,
всегда будет иметь решающее значение: количество обрабатываемых данных легко отстает от Закона Мура за последние десятилетия.

Джулия стремится создать беспрецедентную комбинацию простоты использования, мощности и эффективности в одном языке.
В дополнение к вышесказанному, некоторые преимущества Julia над сопоставимыми системами включают:

  * Бесплатный и открытый исходный код ([MIT лицензия](https://github.com/JuliaLang/julia/blob/master/LICENSE.md))
  * Пользовательские типы являются такими же быстрыми и компактными, как встроенные
  * Нет необходимости векторизовать код для выполнения; невекторизированный код быстр
  * Предназначен для параллелизма и распределенных вычислений
  * Легкие "green" потоки ([coroutines](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0))
  * Ненавязчивая, но мощная система типов
  * Элегантные и расширяемые трансформации (conversions) и стимуляции (promotions) для цифровых и других типов
  * Эффективная поддержка [Unicode](https://ru.wikipedia.org/wiki/Unicode),
    включающая, но не ограниченная, одной лишь [UTF-8](https://ru.wikipedia.org/wiki/UTF-8)
  * Вызов C функций напрямую (без необходимости в обертках или специального API)
  * Мощные шелл-подобные возможности для управления другими процессами
  * Лиспоподобные макросы и другие средства метапрограммирования
